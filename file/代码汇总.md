# ---encoding=utf-8---  
# 在使用maplotlib时由于后端和版本不兼容，导入库时使用：  
# import matplotlib # matplotlib.use("TKagg")  
# import matplotlib.pyplot as plt  
'''  
作者：chemqiang  
日期：2025年09月06日  
'''  
# ---encoding=utf-8---  
# 在使用maplotlib时由于后端和版本不兼容，导入库时使用：  
import matplotlib  
matplotlib.use("TKagg")  
import matplotlib.pyplot as plt  
'''  
作者：chemqiang  
日期：2025年09月05日  
'''  
import numpy as np  
import matplotlib  
matplotlib.use("TKagg")  
import matplotlib.pyplot as plt  
  
# ================== 构造圆柱体的60个关键点 ==================def get_cylinder_60points(R=7, H=10):  
    points = []  
    # 上下底圆各取20点  
    thetas = np.linspace(0, 2*np.pi, 20, endpoint=False)  
    for theta in thetas:  
        x = R*np.cos(theta)  
        y = 200 + R*np.sin(theta)  
        points.append([x, y, 0])   # 下底  
        points.append([x, y, H])   # 上底  
    # 中心轴取10点  
    for z in np.linspace(0, H, 10):  
        points.append([0, 200, z])  
    # 中间圆周取10点  
    thetas_mid = np.linspace(0, 2*np.pi, 10, endpoint=False)  
    for theta in thetas_mid:  
        x = R*np.cos(theta)  
        y = 200 + R*np.sin(theta)  
        points.append([x, y, H/2])  
    return np.array(points)  
  
  
# ================== 遮蔽判定函数（60点目标） ==================def simulate_cylinder_target(  
    M0 = np.array([20000.0, 0.0, 2000.0]),  
    FY1 = np.array([17800.0, 0.0, 1800.0]),  
    origin = np.array([0.0, 0.0, 0.0]),  
    missile_speed = 300.0,  
    drone_speed = 120.0,  
    t_release = 1.5,  
    dt_release_to_explode = 3.6,  
    cloud_radius = 10.0,  
    cloud_effect_duration = 20.0,  
    cloud_sink_speed = 3.0,  
    g = np.array([0.0, 0.0, -9.8]),  
    sample_dt = 0.01  
):  
    # 导弹轨迹  
    u_m = (origin - M0) / np.linalg.norm(origin - M0)  
    v_m = u_m * missile_speed  
  
    # 无人机轨迹  
    D0 = FY1.copy()  
    vec_xy = np.array([origin[0]-D0[0], origin[1]-D0[1], 0.0])  
    u_d_xy = vec_xy / np.linalg.norm(vec_xy)  
    v_d = u_d_xy * drone_speed  
  
    r0 = D0 + v_d * t_release  
    v0 = v_d.copy()  
  
    # 起爆  
    t_explosion = t_release + dt_release_to_explode  
    def B(t):  
        dt = t - t_release  
        return r0 + v0*dt + 0.5*g*dt**2  
    B_explosion = B(t_explosion)  
  
    def C(t):  
        dt = t - t_explosion  
        return B_explosion + np.array([0.0,0.0,-cloud_sink_speed*dt])  
  
    # 时间序列  
    t_hit_origin = np.linalg.norm(M0 - origin) / missile_speed  
    times = np.arange(0.0, t_hit_origin + sample_dt, sample_dt)  
  
    # 目标 60 个关键点  
    keypoints = get_cylinder_60points()  
  
    blocked = np.zeros_like(times, dtype=bool)  
  
    for i, t in enumerate(times):  
        if not (t_explosion <= t <= t_explosion + cloud_effect_duration):  
            continue  
        mpos = M0 + v_m * t  
        cpos = C(t)  
  
        all_covered = True  
        for P in keypoints:  
            ab = P - mpos  
            ab_len = np.linalg.norm(ab)  
            if ab_len == 0:  
                all_covered = False  
                break            dist = np.linalg.norm(np.cross(cpos - mpos, ab)) / ab_len  
            # 云必须在导弹与目标点之间  
            if np.dot(cpos - mpos, ab) < 0:  
                all_covered = False; break  
            if np.dot(P - cpos, ab) < 0:  
                all_covered = False; break  
            if dist > cloud_radius:  
                all_covered = False  
                break        blocked[i] = all_covered  
  
    return blocked, times, B_explosion, t_explosion  
  
  
# ================== 主程序运行 ==================blocked, times, B_explosion, t_explosion = simulate_cylinder_target()  
  
dt = times[1] - times[0]  
effective_time = np.sum(blocked) * dt  
  
intervals = []  
inside = False  
start_t = None  
for t, b in zip(times, blocked):  
    if b and not inside:  
        start_t = t; inside = True  
    if not b and inside:  
        intervals.append((start_t, t)); inside = False  
if inside:  
    intervals.append((start_t, times[-1]))  
  
print("=== 结果（圆柱体60点）===")  
print(f"烟幕起爆时间: {t_explosion:.2f} s")  
print(f"烟幕起爆位置: {B_explosion}")  
print(f"对导弹的有效遮蔽总时长: {effective_time:.2f} s")  
print("遮蔽时间区间:")  
for itv in intervals:  
    print(f"  {itv[0]:.2f} s  ~  {itv[1]:.2f} s")
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTg2MTA4Njg3Nl19
-->