# ---encoding=utf-8---  
# 在使用maplotlib时由于后端和版本不兼容，导入库时使用：  
# import matplotlib # matplotlib.use("TKagg")  
# import matplotlib.pyplot as plt  
'''  
作者：chemqiang  
日期：2025年09月06日  
'''  
# ---encoding=utf-8---  
# 在使用maplotlib时由于后端和版本不兼容，导入库时使用：  
import matplotlib  
matplotlib.use("TKagg")  
import matplotlib.pyplot as plt  
'''  
作者：chemqiang  
日期：2025年09月05日  
'''  
import numpy as np  
import matplotlib  
matplotlib.use("TKagg")  
import matplotlib.pyplot as plt  
  
# ================== 构造圆柱体的60个关键点 ==================def get_cylinder_60points(R=7, H=10):  
    points = []  
    # 上下底圆各取20点  
    thetas = np.linspace(0, 2*np.pi, 20, endpoint=False)  
    for theta in thetas:  
        x = R*np.cos(theta)  
        y = 200 + R*np.sin(theta)  
        points.append([x, y, 0])   # 下底  
        points.append([x, y, H])   # 上底  
    # 中心轴取10点  
    for z in np.linspace(0, H, 10):  
        points.append([0, 200, z])  
    # 中间圆周取10点  
    thetas_mid = np.linspace(0, 2*np.pi, 10, endpoint=False)  
    for theta in thetas_mid:  
        x = R*np.cos(theta)  
        y = 200 + R*np.sin(theta)  
        points.append([x, y, H/2])  
    return np.array(points)  
  
  
# ================== 遮蔽判定函数（60点目标） ==================def simulate_cylinder_target(  
    M0 = np.array([20000.0, 0.0, 2000.0]),  
    FY1 = np.array([17800.0, 0.0, 1800.0]),  
    origin = np.array([0.0, 0.0, 0.0]),  
    missile_speed = 300.0,  
    drone_speed = 120.0,  
    t_release = 1.5,  
    dt_release_to_explode = 3.6,  
    cloud_radius = 10.0,  
    cloud_effect_duration = 20.0,  
    cloud_sink_speed = 3.0,  
    g = np.array([0.0, 0.0, -9.8]),  
    sample_dt = 0.01  
):  
    # 导弹轨迹  
    u_m = (origin - M0) / np.linalg.norm(origin - M0)  
    v_m = u_m * missile_speed  
  
    # 无人机轨迹  
    D0 = FY1.copy()  
    vec_xy = np.array([origin[0]-D0[0], origin[1]-D0[1], 0.0])  
    u_d_xy = vec_xy / np.linalg.norm(vec_xy)  
    v_d = u_d_xy * drone_speed  
  
    r0 = D0 + v_d * t_release  
    v0 = v_d.copy()  
  
    # 起爆  
    t_explosion = t_release + dt_release_to_explode  
    def B(t):  
        dt = t - t_release  
        return r0 + v0*dt + 0.5*g*dt**2  
    B_explosion = B(t_explosion)  
  
    def C(t):  
        dt = t - t_explosion  
        return B_explosion + np.array([0.0,0.0,-cloud_sink_speed*dt])  
  
    # 时间序列  
    t_hit_origin = np.linalg.norm(M0 - origin) / missile_speed  
    times = np.arange(0.0, t_hit_origin + sample_dt, sample_dt)  
  
    # 目标 60 个关键点  
    keypoints = get_cylinder_60points()  
  
    blocked = np.zeros_like(times, dtype=bool)  
  
    for i, t in enumerate(times):  
        if not (t_explosion <= t <= t_explosion + cloud_effect_duration):  
            continue  
        mpos = M0 + v_m * t  
        cpos = C(t)  
  
        all_covered = True  
        for P in keypoints:  
            ab = P - mpos  
            ab_len = np.linalg.norm(ab)  
            if ab_len == 0:  
                all_covered = False  
                break            dist = np.linalg.norm(np.cross(cpos - mpos, ab)) / ab_len  
            # 云必须在导弹与目标点之间  
            if np.dot(cpos - mpos, ab) < 0:  
                all_covered = False; break  
            if np.dot(P - cpos, ab) < 0:  
                all_covered = False; break  
            if dist > cloud_radius:  
                all_covered = False  
                break        blocked[i] = all_covered  
  
    return blocked, times, B_explosion, t_explosion  
  
  
# ================== 主程序运行 ==================blocked, times, B_explosion, t_explosion = simulate_cylinder_target()  
  
dt = times[1] - times[0]  
effective_time = np.sum(blocked) * dt  
  
intervals = []  
inside = False  
start_t = None  
for t, b in zip(times, blocked):  
    if b and not inside:  
        start_t = t; inside = True  
    if not b and inside:  
        intervals.append((start_t, t)); inside = False  
if inside:  
    intervals.append((start_t, times[-1]))  
  
print("=== 结果（圆柱体60点）===")  
print(f"烟幕起爆时间: {t_explosion:.2f} s")  
print(f"烟幕起爆位置: {B_explosion}")  
print(f"对导弹的有效遮蔽总时长: {effective_time:.2f} s")  
print("遮蔽时间区间:")  
for itv in intervals:  
    print(f"  {itv[0]:.2f} s  ~  {itv[1]:.2f} s")




# ---encoding=utf-8---  
# 在使用maplotlib时由于后端和版本不兼容，导入库时使用：  
import matplotlib  
matplotlib.use("TKagg")  
import matplotlib.pyplot as plt  
'''  
作者：chemqiang  
日期：2025年09月06日  
'''  
  
  
import matplotlib  
matplotlib.use("TKagg")  
import matplotlib.pyplot as plt  
import numpy as np  
import time  
plt.rcParams['font.sans-serif'] = ['SimHei',"WenQuanYi Micro Hei","Heiti TC"]  
  
# -------------------------  
# 向量化目标函数（无人机遮蔽时间仿真）  
# -------------------------  
def simulate_point_target_correct(x, sample_dt=0.01):  
    drone_speed, theta, t_release, dt_release_to_explode = x  
    M0 = np.array([20000.0, 0.0, 2000.0])  
    FY1 = np.array([17800.0, 0.0, 1800.0])  
    origin = np.array([0.0, 0.0, 0.0])  
    true_target_point = np.array([0.0, 200.0, 5.0])  
    missile_speed = 300.0  
    cloud_radius = 10.0  
    cloud_effect_duration = 20.0  
    cloud_sink_speed = 3.0  
    g = np.array([0.0, 0.0, -9.8])  
  
    u_m = (origin - M0) / np.linalg.norm(origin - M0)  
    v_m = u_m * missile_speed  
  
    vec_xy = np.array([drone_speed*np.sin(theta), drone_speed*np.cos(theta), 0.0])  
    if np.linalg.norm(vec_xy) == 0:  
        u_d_xy = np.array([0.0, 1.0, 0.0])  
    else:  
        u_d_xy = vec_xy / np.linalg.norm(vec_xy)  
    v_d = u_d_xy * drone_speed  
  
    r0 = FY1 + v_d * t_release  
    v0 = v_d.copy()  
  
    t_explosion = t_release + dt_release_to_explode  
    B_explosion = r0 + v0*(t_explosion - t_release) + 0.5*g*(t_explosion - t_release)**2  
  
    def C_times(times):  
        dt = times - t_explosion  
        return B_explosion[np.newaxis,:] + np.stack([np.zeros_like(dt), np.zeros_like(dt), -cloud_sink_speed*dt], axis=1)  
  
    t_hit_origin = np.linalg.norm(M0 - origin) / missile_speed  
    times = np.arange(0.0, t_hit_origin + sample_dt, sample_dt)  
    mpos = M0[np.newaxis,:] + v_m[np.newaxis,:]*times[:,None]  
    cpos = C_times(times)  
  
    mask_active = (times >= t_explosion) & (times <= t_explosion + cloud_effect_duration)  
    if not mask_active.any():  
        return -1e-6  
  
    b = true_target_point[np.newaxis,:]  
    ab = b - mpos  
    ab_len2 = np.sum(ab**2, axis=1)  
    ab_len2_safe = np.where(ab_len2 == 0, 1e-12, ab_len2)  
    tproj = np.sum((cpos - mpos)*ab, axis=1) / ab_len2_safe  
    within = (tproj >= 0) & (tproj <= 1) & mask_active  
    closest = mpos + (tproj[:,None]*ab)  
    dists = np.linalg.norm(cpos - closest, axis=1)  
    blocked = (dists <= cloud_radius) & within  
  
    total_block = blocked.sum()*sample_dt  
    return -total_block  
  
# -------------------------  
# 简易 PSO# -------------------------  
class SimplePSO:  
    def __init__(self, func, dim, pop=40, max_iter=60, lb=None, ub=None, w=0.7, c1=2.0, c2=2.0, seed=1):  
        self.func = func  
        self.dim = dim  
        self.pop = pop  
        self.max_iter = max_iter  
        self.lb = np.array(lb)  
        self.ub = np.array(ub)  
        self.w = w  
        self.c1 = c1  
        self.c2 = c2  
        np.random.seed(seed)  
        self.X = np.random.rand(self.pop, self.dim)*(self.ub - self.lb) + self.lb  
        self.V = np.random.randn(self.pop, self.dim)*0.1*(self.ub - self.lb)  
        self.pbest_x = self.X.copy()  
        self.pbest_y = np.array([self.func(x) for x in self.X])  
        idx = np.argmin(self.pbest_y)  
        self.gbest_x = self.pbest_x[idx].copy()  
        self.gbest_y = self.pbest_y[idx]  
        self.gbest_y_hist = [self.gbest_y]  
        self.iter = 0  
        self.vmax = 0.5*(self.ub - self.lb)  
        self.vmin = -self.vmax  
  
    def update_w(self):  
        pass  
  
    def run(self):  
        for it in range(1, self.max_iter+1):  
            self.iter = it  
            r1 = np.random.rand(self.pop, self.dim)  
            r2 = np.random.rand(self.pop, self.dim)  
            cognitive = self.c1*r1*(self.pbest_x - self.X)  
            social = self.c2*r2*(self.gbest_x - self.X)  
            self.V = self.w*self.V + cognitive + social  
            self.V = np.clip(self.V, self.vmin, self.vmax)  
            self.X = self.X + self.V  
            self.X = np.clip(self.X, self.lb, self.ub)  
            Ys = np.array([self.func(x) for x in self.X])  
            improved = Ys < self.pbest_y  
            self.pbest_y = np.where(improved, Ys, self.pbest_y)  
            self.pbest_x = np.where(improved[:,None], self.X, self.pbest_x)  
            idx = np.argmin(self.pbest_y)  
            if self.pbest_y[idx] < self.gbest_y:  
                self.gbest_y = self.pbest_y[idx]  
                self.gbest_x = self.pbest_x[idx].copy()  
            self.gbest_y_hist.append(self.gbest_y)  
        return self.gbest_x, self.gbest_y, self.gbest_y_hist  
  
# -------------------------  
# 区间组合搜索  
# -------------------------  
if __name__ == "__main__":  
    drone_speed_range = [70, 140]  
    theta_range = [-np.pi, np.pi]  
  
    # 划分 t_release 和 dt_release_to_explode 区间  
    t_start, t_end, t_step = 0.5, 60, 3.5  
    dt_start, dt_end, dt_step = 1, 19, 9  
  
    t_intervals = [(t, min(t+t_step, t_end)) for t in np.arange(t_start, t_end, t_step)]  
    dt_intervals = [(dt, min(dt+dt_step, dt_end)) for dt in np.arange(dt_start, dt_end, dt_step)]  
  
    results = []  
    start = time.time()  
  
    for t_lb, t_ub in t_intervals:  
        for dt_lb, dt_ub in dt_intervals:  
            lb=[drone_speed_range[0], theta_range[0], t_lb, dt_lb]  
            ub=[drone_speed_range[1], theta_range[1], t_ub, dt_ub]  
            print(f"运行组合 t_release:{t_lb}-{t_ub}, dt_explode:{dt_lb}-{dt_ub}")  
            pso = SimplePSO(func=simulate_point_target_correct, dim=4, pop=40, max_iter=80, lb=lb, ub=ub, seed=42)  
            best_x, best_y, hist = pso.run()  
            max_block_time = -best_y  
            results.append(((t_lb,t_ub,dt_lb,dt_ub), max_block_time))  
            print(f"最优遮蔽时间: {max_block_time:.3f} s")  
  
    end = time.time()  
    print("总耗时:", end-start,"秒")  
  
    # 按遮蔽时间排序  
    results.sort(key=lambda r: r[1], reverse=True)  
  
    # 绘图  
    labels = [f"t:{r[0][0]}-{r[0][1]}, dt:{r[0][2]}-{r[0][3]}" for r in results]  
    values = [r[1] for r in results]  
    plt.figure(figsize=(12,6))  
    plt.bar(range(len(values)), values)  
    plt.xticks(range(len(values)), labels, rotation=45, ha='right')  
    plt.ylabel("最大遮蔽时间 (秒)")  
    plt.title("不同 t_release 和 dt_release 区间组合的最优遮蔽时间")  
    plt.grid(True)  
    plt.tight_layout()  
    plt.show()








#---encoding=utf-8---  
#在使用maplotlib时由于后端和版本不兼容，导入库时使用：  
import matplotlib  
matplotlib.use("TKagg")  
import matplotlib.pyplot as plt  
'''  
作者：chemqiang  
日期：2025年09月06日  
'''  
# ---encoding=utf-8---  
import numpy as np  
import pandas as pd  
import itertools  
import random  
  
# ================== 关键点 ==================# -*- coding: utf-8 -*-  
# -*- coding: utf-8 -*-  
# -*- coding: utf-8 -*-  
  
# 你看到第一段比第二段快，主要原因是：  
#  
# 第一段目标函数提前筛掉无效时间段，减少计算量。  
#  
# 第一段向量化处理核心矩阵计算，完全在 C 层执行，而第二段每步循环调用 Python 函数，开销大。  
#  
# PSO 库实现为了通用性和安全性，增加了历史记录和多次函数调用开销。  
#  
# 所以，虽然第二段看起来“向量化 + 库实现”，在这个具体问题上反而慢，因为循环次数和判断条件更多。  
plt.rcParams['font.sans-serif'] = ['SimHei',"WenQuanYi Micro Hei","Heiti TC"]  
import numpy as np  
import matplotlib.pyplot as plt  
import time  
  
# -------------------------  
# 向量化目标函数（无人机遮蔽时间仿真）  
# -------------------------  
def simulate_point_target_correct(x, sample_dt=0.01):  
    drone_speed, theta, t_release, dt_release_to_explode = x  
    M0 = np.array([20000.0, 0.0, 2000.0])   # 导弹初始位置  
    FY1 = np.array([17800.0, 0.0, 1800.0])  # 无人机初始位置  
    origin = np.array([0.0, 0.0, 0.0])      # 假目标  
    true_target_point = np.array([0.0, 200.0, 5.0]) # 真目标  
    missile_speed = 300.0  
    cloud_radius = 10.0  
    cloud_effect_duration = 20.0  
    cloud_sink_speed = 3.0  
    g = np.array([0.0, 0.0, -9.8])  
  
    # 导弹速度向量  
    u_m = (origin - M0) / np.linalg.norm(origin - M0)  
    v_m = u_m * missile_speed  
  
    # 无人机速度向量  
    vec_xy = np.array([drone_speed*np.sin(theta), drone_speed*np.cos(theta), 0.0])  
    if np.linalg.norm(vec_xy) == 0:  
        u_d_xy = np.array([0.0, 1.0, 0.0])  
    else:  
        u_d_xy = vec_xy / np.linalg.norm(vec_xy)  
    v_d = u_d_xy * drone_speed  
  
    # 投放点位置  
    r0 = FY1 + v_d * t_release  
    v0 = v_d.copy()  
  
    # 起爆时刻与位置  
    t_explosion = t_release + dt_release_to_explode  
    B_explosion = r0 + v0*(t_explosion - t_release) + 0.5*g*(t_explosion - t_release)**2  
  
    # 云心位置随时间变化  
    def C_times(times):  
        dt = times - t_explosion  
        return B_explosion[np.newaxis,:] + np.stack([np.zeros_like(dt), np.zeros_like(dt), -cloud_sink_speed*dt], axis=1)  
  
    # 导弹到达原点时间  
    t_hit_origin = np.linalg.norm(M0 - origin) / missile_speed  
  
    # 采样时间  
    times = np.arange(0.0, t_hit_origin + sample_dt, sample_dt)  
    mpos = M0[np.newaxis,:] + v_m[np.newaxis,:]*times[:,None]  
    cpos = C_times(times)  
  
    # 是否在云层有效时间  
    mask_active = (times >= t_explosion) & (times <= t_explosion + cloud_effect_duration)  
    if not mask_active.any():  
        return -0.0  
  
    # 投影计算  
    b = true_target_point[np.newaxis,:]  
    ab = b - mpos  
    ab_len2 = np.sum(ab**2, axis=1)  
    ab_len2_safe = np.where(ab_len2 == 0, 1e-12, ab_len2)  
    tproj = np.sum((cpos - mpos)*ab, axis=1) / ab_len2_safe  
    within = (tproj >= 0) & (tproj <= 1) & mask_active  
    closest = mpos + (tproj[:,None]*ab)  
    dists = np.linalg.norm(cpos - closest, axis=1)  
    blocked = (dists <= cloud_radius) & within  
  
    total_block = blocked.sum()*sample_dt  
    return -1.0 * total_block  # 取负号 → PSO 求最小化  
  
# -------------------------  
# 简易 PSO 实现  
# -------------------------  
class SimplePSO:  
    def __init__(self, func, dim, pop=50, max_iter=60, lb=None, ub=None,  
                 w=0.7, c1=2.0, c2=2.0, seed=1):  
        self.func = func  
        self.dim = dim  
        self.pop = pop  
        self.max_iter = max_iter  
        self.lb = np.array(lb)  
        self.ub = np.array(ub)  
        self.w = w  
        self.c1 = c1  
        self.c2 = c2  
        np.random.seed(seed)  
  
        # 初始化粒子  
        self.X = np.random.rand(self.pop, self.dim)*(self.ub - self.lb) + self.lb  
        self.V = np.random.randn(self.pop, self.dim)*0.1*(self.ub - self.lb)  
  
        self.pbest_x = self.X.copy()  
        self.pbest_y = np.array([self.func(x) for x in self.X])  
        idx = np.argmin(self.pbest_y)  
        self.gbest_x = self.pbest_x[idx].copy()  
        self.gbest_y = self.pbest_y[idx]  
        self.gbest_y_hist = [self.gbest_y]  
        self.iter = 0  
  
        self.vmax = 0.5*(self.ub - self.lb)  
        self.vmin = -self.vmax  
  
    def update_w(self):  
        return  
  
    def run(self):  
        for it in range(1, self.max_iter+1):  
            self.iter = it  
            self.update_w()  
  
            r1 = np.random.rand(self.pop, self.dim)  
            r2 = np.random.rand(self.pop, self.dim)  
            cognitive = self.c1*r1*(self.pbest_x - self.X)  
            social = self.c2*r2*(self.gbest_x - self.X)  
  
            self.V = self.w*self.V + cognitive + social  
            self.V = np.clip(self.V, self.vmin, self.vmax)  
  
            self.X = self.X + self.V  
            self.X = np.clip(self.X, self.lb, self.ub)  
  
            Ys = np.array([self.func(x) for x in self.X])  
            improved = Ys < self.pbest_y  
            self.pbest_y = np.where(improved, Ys, self.pbest_y)  
            self.pbest_x = np.where(improved[:,None], self.X, self.pbest_x)  
  
            idx = np.argmin(self.pbest_y)  
            if self.pbest_y[idx] < self.gbest_y:  
                self.gbest_y = self.pbest_y[idx]  
                self.gbest_x = self.pbest_x[idx].copy()  
  
            self.gbest_y_hist.append(self.gbest_y)  
  
        return self.gbest_x, self.gbest_y, self.gbest_y_hist  
  
# -------------------------  
# 各种惯性权重策略  
# -------------------------  
class PSO_Fixed(SimplePSO):  
    def __init__(self,*a,w=0.7,**k): super().__init__(*a,**k); self.w=w  
  
class PSO_Linear_Decreasing(SimplePSO):  
    def __init__(self,*a,w_start=0.9,w_end=0.4,**k):  
        super().__init__(*a,**k); self.w_start=w_start; self.w_end=w_end; self.w=w_start  
    def update_w(self): self.w=self.w_start-(self.w_start-self.w_end)*(self.iter/self.max_iter)  
  
class PSO_Adaptive(SimplePSO):  
    def __init__(self,*a,w_start=0.9,w_end=0.4,**k):  
        super().__init__(*a,**k); self.w_start=w_start; self.w_end=w_end; self.w=w_start  
    def update_w(self):  
        if self.iter>1 and len(self.gbest_y_hist)>=2:  
            if self.gbest_y_hist[-1] < self.gbest_y_hist[-2]:  
                self.w=max(self.w*0.99,self.w_end)  
            else:  
                self.w=min(self.w*1.01,self.w_start)  
  
class PSO_Osculating(SimplePSO):  
    def __init__(self,*a,w_max=0.9,w_min=0.4,**k):  
        super().__init__(*a,**k); self.w_max=w_max; self.w_min=w_min; self.w=w_max  
    def update_w(self): self.w=self.w_max-(self.w_max-self.w_min)*(self.iter/self.max_iter)**2  
  
class PSO_Time_Varying(SimplePSO):  
    def __init__(self,*a,w_max=0.9,w_min=0.4,**k):  
        super().__init__(*a,**k); self.w_max=w_max; self.w_min=w_min; self.w=w_max  
    def update_w(self): self.w=(self.w_max-self.w_min)*np.exp(-self.iter/self.max_iter)+self.w_min  
  
# -------------------------  
# 主程序  
# -------------------------  
if __name__ == "__main__":  
    strategies = [  
        ("固定", PSO_Fixed),  
        ("线性递减", PSO_Linear_Decreasing),  
        ("自适应", PSO_Adaptive),  
        ("振荡", PSO_Osculating),  
        ("时变", PSO_Time_Varying)  
    ]  
    lb=[70,-1*np.pi,0.5,1]  
    ub=[140,np.pi,4,10]  
  
    results=[]  
    start=time.time()  
    for name,Cls in strategies:  
        print(f"\n正在运行 {name} 策略...")  
        pso=Cls(func=simulate_point_target_correct,dim=4,pop=40,max_iter=120,lb=lb,ub=ub,seed=42)  
        bx,by,hist=pso.run()  
        results.append((name,hist,bx,by))  
        print(f"{name}: best_x={bx}, 最大遮蔽时长={-by:.3f} 秒")  
  
    print("耗时:", time.time()-start,"秒")  
  
    # 绘制收敛曲线  
    plt.figure(figsize=(10,6))  
    for name,hist,bx,by in results:  
        plt.plot([-y for y in hist],label=f"{name}(最优{-by:.2f}s)")  
    plt.xlabel("迭代次数");plt.ylabel("遮蔽时长 (秒)")  
    plt.title("不同惯性权重策略的收敛曲线")  
    plt.grid(True);plt.legend();plt.show()  
  
    # 输出全局最优并文字描述每个参数  
    best = min(results, key=lambda r: r[3])  
    best_name = best[0]  
    best_x = best[2]  
    best_y = -best[3]  
  
    print("\n最优策略:", best_name)  
    print(f"最大遮蔽时长: {best_y:.2f} 秒")  
    print("无人机最优参数及含义:")  
  
    param_names = ["无人机速度 (drone_speed, m/s)",  
                   "航向角 (theta, rad)",  
                   "投放时刻 (t_release, s)",  
                   "投放到爆炸延迟 (dt_release_to_explode, s)"]  
  
    param_desc = [  
        "无人机在 XY 平面上的飞行速度，速度越快可以更快到达投放点。",  
        "无人机在 XY 平面上的飞行方向，0 表示沿 Y 轴正方向，正值偏向 X 轴正方向。",  
        "无人机从起飞到投放云雾的时间，决定云雾投放位置和导弹遇到云雾时机。",  
        "云雾从投放到达到最大遮蔽效果的延迟时间，控制云雾沉降高度和持续时间。"  
    ]  
  
    for name, val, desc in zip(param_names, best_x, param_desc):  
        print(f"- {name}: {val:.3f} → {desc}")









# 在使用maplotlib时由于后端和版本不兼容，导入库时使用：  
import matplotlib  
matplotlib.use("TKagg")  
import matplotlib.pyplot as plt  
import matplotlib.pyplot as plt  
plt.rcParams['font.sans-serif'] = ['SimHei',"WenQuanYi Micro Hei","Heiti TC"]  
'''  
作者：chemqiang  
日期：2025年09月07日  
'''  
import numpy as np  
import pandas as pd  
import matplotlib  
  
matplotlib.use("TkAgg")  
import matplotlib.pyplot as plt  
  
'''  
作者：chemqiang（最终版）  
日期：2025年09月07日  
'''  
  
  
# -------------------------  
# 模拟单枚干扰弹对 M1 遮蔽效果  
# -------------------------  
def simulate_point_target_correct_joint_with_time_constraint(x, sample_dt=0.01):  
    drone_speed, theta = x[0], x[1]  
    t_releases = x[2::2]  
    dt_explodes = x[3::2]  
  
    # 模拟参数  
    M0 = np.array([20000.0, 0.0, 2000.0])  
    FY1 = np.array([17800.0, 0.0, 1800.0])  
    origin = np.array([0.0, 0.0, 0.0])  
    true_target_point = np.array([0.0, 200.0, 5.0])  
    missile_speed = 300.0  
    cloud_radius = 10.0  
    cloud_effect_duration = 20.0  
    cloud_sink_speed = 3.0  
    g = np.array([0.0, 0.0, -9.8])  
  
    # 导弹速度  
    u_m = (origin - M0) / np.linalg.norm(origin - M0)  
    v_m = u_m * missile_speed  
  
    # 无人机速度向量  
    vec_xy = np.array([drone_speed * np.sin(theta), drone_speed * np.cos(theta), 0.0])  
    u_d_xy = vec_xy / np.linalg.norm(vec_xy) if np.linalg.norm(vec_xy) != 0 else np.array([0.0, 1.0, 0.0])  
    v_d = u_d_xy * drone_speed  
  
    t_hit_origin = np.linalg.norm(M0 - origin) / missile_speed  
    times = np.arange(0.0, t_hit_origin + sample_dt, sample_dt)  
    mpos = M0[np.newaxis, :] + v_m[np.newaxis, :] * times[:, None]  
  
    blocked_total = np.zeros_like(times, dtype=bool)  
    for t_release, dt_explode in zip(t_releases, dt_explodes):  
        if t_release <= 0 or dt_explode <= 0:  # 被置零的干扰弹不计算  
            continue  
        r0 = FY1 + v_d * t_release  
        t_explosion = t_release + dt_explode  
        B_explosion = r0 + v_d * (t_explosion - t_release) + 0.5 * g * (t_explosion - t_release) ** 2  
        dt = times - t_explosion  
        cpos = B_explosion[np.newaxis, :] + np.stack([np.zeros_like(dt), np.zeros_like(dt), -cloud_sink_speed * dt],  
                                                     axis=1)  
        mask_active = (times >= t_explosion) & (times <= t_explosion + cloud_effect_duration)  
        if not mask_active.any(): continue  
        b = true_target_point[np.newaxis, :]  
        ab = b - mpos  
        ab_len2 = np.sum(ab ** 2, axis=1)  
        ab_len2_safe = np.where(ab_len2 == 0, 1e-12, ab_len2)  
        tproj = np.sum((cpos - mpos) * ab, axis=1) / ab_len2_safe  
        within = (tproj >= 0) & (tproj <= 1) & mask_active  
        closest = mpos + (tproj[:, None] * ab)  
        dists = np.linalg.norm(cpos - closest, axis=1)  
        blocked = (dists <= cloud_radius) & within  
        blocked_total = blocked_total | blocked  
  
    total_block_time = blocked_total.sum() * sample_dt  
    return -total_block_time  
  
  
# -------------------------  
# PSO 基类及五种策略  
# -------------------------  
class SimplePSO:  
    def __init__(self, func, dim, pop=40, max_iter=120, lb=None, ub=None,  
                 w=0.7, c1=2.0, c2=2.0, seed=42):  
        self.func = func  
        self.dim = dim  
        self.pop = pop  
        self.max_iter = max_iter  
        self.lb = np.array(lb)  
        self.ub = np.array(ub)  
        self.w = w  
        self.c1 = c1  
        self.c2 = c2  
        np.random.seed(seed)  
        self.X = np.random.rand(pop, dim) * (self.ub - self.lb) + self.lb  
        self.V = np.random.randn(pop, dim) * 0.1 * (self.ub - self.lb)  
        self.pbest_x = self.X.copy()  
        self.pbest_y = np.array([self.func(x) for x in self.X])  
        idx = np.argmin(self.pbest_y)  
        self.gbest_x = self.pbest_x[idx].copy()  
        self.gbest_y = self.pbest_y[idx]  
        self.gbest_y_hist = [self.gbest_y]  
        self.vmax = 0.5 * (self.ub - self.lb)  
        self.vmin = -self.vmax  
        self.iter = 0  
  
    def update_w(self):  
        return  
  
    def run(self):  
        for it in range(1, self.max_iter + 1):  
            self.iter = it  
            self.update_w()  
            r1 = np.random.rand(self.pop, self.dim)  
            r2 = np.random.rand(self.pop, self.dim)  
            cognitive = self.c1 * r1 * (self.pbest_x - self.X)  
            social = self.c2 * r2 * (self.gbest_x - self.X)  
            self.V = self.w * self.V + cognitive + social  
            self.V = np.clip(self.V, self.vmin, self.vmax)  
            self.X = self.X + self.V  
            self.X = np.clip(self.X, self.lb, self.ub)  
            Ys = np.array([self.func(x) for x in self.X])  
            improved = Ys < self.pbest_y  
            self.pbest_y = np.where(improved, Ys, self.pbest_y)  
            self.pbest_x = np.where(improved[:, None], self.X, self.pbest_x)  
            idx = np.argmin(self.pbest_y)  
            if self.pbest_y[idx] < self.gbest_y:  
                self.gbest_y = self.pbest_y[idx]  
                self.gbest_x = self.pbest_x[idx].copy()  
            self.gbest_y_hist.append(self.gbest_y)  
        return self.gbest_x, self.gbest_y, self.gbest_y_hist  
  
  
class PSO_Fixed(SimplePSO):  # 固定  
    def __init__(self, *a, w=0.7, **k): super().__init__(*a, **k); self.w = w  
  
  
class PSO_Linear_Decreasing(SimplePSO):  
    def __init__(self, *a, w_start=0.9, w_end=0.4, **k): super().__init__(*a,  
                                                                          **k); self.w_start = w_start; self.w_end = w_end; self.w = w_start  
  
    def update_w(self): self.w = self.w_start - (self.w_start - self.w_end) * (self.iter / self.max_iter)  
  
  
class PSO_Adaptive(SimplePSO):  
    def __init__(self, *a, w_start=0.9, w_end=0.4, **k): super().__init__(*a,  
                                                                          **k); self.w_start = w_start; self.w_end = w_end; self.w = w_start  
  
    def update_w(self):  
        if self.iter > 1 and len(self.gbest_y_hist) >= 2:  
            self.w = max(min(self.w * 1.01, self.w_start), self.w_end) if self.gbest_y_hist[-1] >= self.gbest_y_hist[  
                -2] else max(min(self.w * 0.99, self.w_start), self.w_end)  
  
  
class PSO_Osculating(SimplePSO):  
    def __init__(self, *a, w_max=0.9, w_min=0.4, **k): super().__init__(*a,  
                                                                        **k); self.w_max = w_max; self.w_min = w_min; self.w = w_max  
  
    def update_w(self): self.w = self.w_max - (self.w_max - self.w_min) * (self.iter / self.max_iter) ** 2  
  
  
class PSO_Time_Varying(SimplePSO):  
    def __init__(self, *a, w_max=0.9, w_min=0.4, **k): super().__init__(*a,  
                                                                        **k); self.w_max = w_max; self.w_min = w_min; self.w = w_max  
  
    def update_w(self): self.w = (self.w_max - self.w_min) * np.exp(-self.iter / self.max_iter) + self.w_min  
  
  
# -------------------------  
# 优化三枚干扰弹 + 输出指定格式 Excel# -------------------------  
def optimize_3_clouds_all_strategies_direct_time():  
    drone_speed_lb, drone_speed_ub = 70, 140  
    theta_lb, theta_ub = -np.pi, np.pi  
    explode_lb, explode_ub = 1, 10  
  
    # 投放时间直接约束，保证间隔 >=1    t1_lb, t1_ub = 0.5, 2.0  
    t2_lb, t2_ub = t1_lb + 1, 3.0  
    t3_lb, t3_ub = t2_lb + 1, 4.0  
  
    lb = [drone_speed_lb, theta_lb, t1_lb, explode_lb, t2_lb, explode_lb, t3_lb, explode_lb]  
    ub = [drone_speed_ub, theta_ub, t1_ub, explode_ub, t2_ub, explode_ub, t3_ub, explode_ub]  
  
    strategies = [  
        ("固定", PSO_Fixed),  
        ("线性递减", PSO_Linear_Decreasing),  
        ("自适应", PSO_Adaptive),  
        ("振荡", PSO_Osculating),  
        ("时变", PSO_Time_Varying)  
    ]  
  
    results_summary = []  
    for name, Cls in strategies:  
        print(f"\n=== 策略: {name} ===")  
        pso = Cls(func=simulate_point_target_correct_joint_with_time_constraint, dim=8, pop=50, max_iter=150, lb=lb,  
                  ub=ub)  
        best_x, best_y, hist = pso.run()  
  
        # 确保投放时间间隔 >=1        t_releases = best_x[2::2]  
        t_releases[1] = max(t_releases[1], t_releases[0] + 1)  
        t_releases[2] = max(t_releases[2], t_releases[1] + 1)  
        best_x[2::2] = t_releases  
  
        total_cover = -simulate_point_target_correct_joint_with_time_constraint(best_x)  
        results_summary.append((name, total_cover, best_x))  
        print(f"总遮蔽时间: {total_cover:.2f}s")  
  
    # 绘制柱状图  
    names, totals, _ = zip(*results_summary)  
    plt.figure(figsize=(10, 6))  
    plt.bar(names, totals, color='skyblue')  
    plt.ylabel("三枚干扰弹总遮蔽时间 (秒)")  
    plt.title("不同权重策略下总遮蔽时间比较")  
    plt.grid(axis='y')  
    plt.show()  
  
    # 输出最优策略  
    best_strategy_name, best_total, best_x = max(results_summary, key=lambda x: x[1])  
    print(f"\n最优策略: {best_strategy_name}, 总遮蔽时间={best_total:.2f}s")  
  
    # Excel 输出  
    drone_speed = best_x[0]  
    theta = best_x[1]  
    direction_deg = (np.degrees(theta) % 360)  
    t_releases = best_x[2::2]  
    dt_explodes = best_x[3::2]  
  
    results = []  
    for i, (t_release, dt_explode) in enumerate(zip(t_releases, dt_explodes)):  
        x_single = best_x.copy()  
        for j in range(3):  
            if j != i:  
                x_single[2 + 2 * j] = 0  
                x_single[3 + 2 * j] = 0  
        cover_time = -simulate_point_target_correct_joint_with_time_constraint(x_single)  
  
        # 投放点坐标  
        r0 = np.array([17800.0, 0.0, 1800.0]) + np.array(  
            [drone_speed * np.sin(theta), drone_speed * np.cos(theta), 0.0]) * t_release  
        # 起爆点坐标  
        t_explosion = t_release + dt_explode  
        B_explosion = r0 + 0.5 * np.array([0.0, 0.0, -9.8]) * (dt_explode ** 2)  
  
        results.append({  
            "无人机运动方向": direction_deg,  
            "无人机运动速度 (m/s)": drone_speed,  
            "烟幕干扰弹编号": i + 1,  
            "烟幕干扰弹投放点的x坐标 (m)": r0[0],  
            "烟幕干扰弹投放点的y坐标 (m)": r0[1],  
            "烟幕干扰弹投放点的z坐标 (m)": r0[2],  
            "烟幕干扰弹起爆点的x坐标 (m)": B_explosion[0],  
            "烟幕干扰弹起爆点的y坐标 (m)": B_explosion[1],  
            "烟幕干扰弹起爆点的z坐标 (m)": B_explosion[2],  
            "有效干扰时长 (s)": cover_time  
        })  
  
    df = pd.DataFrame(results)  
    df.to_excel("result1.xlsx", index=False)  
    print("最优策略结果已保存到 result1.xlsx")  
    return df  
  
  
if __name__ == "__main__":  
    df = optimize_3_clouds_all_strategies_direct_time()  
    print(df)







  
'''  
作者：chemqiang  
日期：2025年09月07日  
'''  
# ---encoding=utf-8---  
# 在使用matplotlib时由于后端和版本不兼容，导入库时使用：  
import numpy as np  
import matplotlib.pyplot as plt  
import matplotlib  
matplotlib.use("TKagg")  
plt.rcParams['font.sans-serif'] = ['SimHei',"WenQuanYi Micro Hei","Heiti TC"]  
import time  
  
# -------------------------  
# 模拟无人机投放遮蔽云增量遮蔽时间  
# -------------------------  
def simulate_incremental(x, FY, existing_clouds=[], sample_dt=0.01):  
    drone_speed, theta, t_release, dt_release_to_explode = x  
    M0 = np.array([20000.0, 0.0, 2000.0])  # 导弹初始位置  
    origin = np.array([0.0, 0.0, 0.0])     # 假目标  
    true_target_point = np.array([0.0, 200.0, 5.0])  
    missile_speed = 300.0  
    cloud_radius = 10.0  
    cloud_effect_duration = 20.0  
    cloud_sink_speed = 3.0  
    g = np.array([0.0, 0.0, -9.8])  
  
    # 导弹速度向量  
    u_m = (origin - M0) / np.linalg.norm(origin - M0)  
    v_m = u_m * missile_speed  
  
    # 无人机速度向量  
    vec_xy = np.array([drone_speed*np.sin(theta), drone_speed*np.cos(theta), 0.0])  
    u_d_xy = vec_xy/np.linalg.norm(vec_xy) if np.linalg.norm(vec_xy) != 0 else np.array([0,1,0])  
    v_d = u_d_xy * drone_speed  
  
    # 投放点和爆炸位置  
    r0 = FY + v_d*t_release  
    v0 = v_d.copy()  
    t_explosion = t_release + dt_release_to_explode  
    B_explosion = r0 + v0*(t_explosion - t_release) + 0.5*g*(t_explosion - t_release)**2  
  
    # 云心位置随时间变化  
    def C_times(times):  
        dt = times - t_explosion  
        return B_explosion[np.newaxis,:] + np.stack([np.zeros_like(dt), np.zeros_like(dt), -cloud_sink_speed*dt], axis=1)  
  
    t_hit_origin = np.linalg.norm(M0-origin)/missile_speed  
    times = np.arange(0.0, t_hit_origin+sample_dt, sample_dt)  
    mpos = M0[np.newaxis,:] + v_m[np.newaxis,:]*times[:,None]  
    cpos = C_times(times)  
  
    # 云有效时间  
    mask_active = (times>=t_explosion) & (times<=t_explosion+cloud_effect_duration)  
    if not mask_active.any():  
        return 0.0  
  
    # 投影计算遮蔽  
    b = true_target_point[np.newaxis,:]  
    ab = b - mpos  
    ab_len2 = np.sum(ab**2, axis=1)  
    ab_len2_safe = np.where(ab_len2==0, 1e-12, ab_len2)  
    tproj = np.sum((cpos - mpos)*ab, axis=1)/ab_len2_safe  
    within = (tproj>=0) & (tproj<=1) & mask_active  
    closest = mpos + (tproj[:,None]*ab)  
    dists = np.linalg.norm(cpos - closest, axis=1)  
    blocked = (dists <= cloud_radius) & within  
  
    # 考虑已有遮蔽  
    for cloud in existing_clouds:  
        blocked = blocked & (~cloud)  
  
    total_block = blocked.sum()*sample_dt  
    return total_block  
  
# -------------------------  
# 基础PSO类  
# -------------------------  
class SimplePSO:  
    def __init__(self, func, dim, pop=40, max_iter=120, lb=None, ub=None, c1=2.0, c2=2.0, seed=42):  
        self.func = func  
        self.dim = dim  
        self.pop = pop  
        self.max_iter = max_iter  
        self.lb = np.array(lb)  
        self.ub = np.array(ub)  
        self.c1 = c1  
        self.c2 = c2  
        np.random.seed(seed)  
  
        # 初始化粒子  
        self.X = np.random.rand(self.pop,self.dim)*(self.ub-self.lb)+self.lb  
        self.V = np.random.randn(self.pop,self.dim)*0.1*(self.ub-self.lb)  
        self.pbest_x = self.X.copy()  
        self.pbest_y = np.array([self.func(x) for x in self.X])  
        idx = np.argmax(self.pbest_y)  
        self.gbest_x = self.pbest_x[idx].copy()  
        self.gbest_y = self.pbest_y[idx]  
        self.gbest_y_hist = [self.gbest_y]  
        self.iter = 0  
        self.vmax = 0.5*(self.ub-self.lb)  
        self.vmin = -self.vmax  
        self.w = 0.7  
  
    def update_w(self):  
        pass  
  
    def run(self):  
        for it in range(1,self.max_iter+1):  
            self.iter = it  
            self.update_w()  
            r1 = np.random.rand(self.pop,self.dim)  
            r2 = np.random.rand(self.pop,self.dim)  
            cognitive = self.c1*r1*(self.pbest_x - self.X)  
            social = self.c2*r2*(self.gbest_x - self.X)  
            self.V = self.w*self.V + cognitive + social  
            self.V += 0.05*(self.ub-self.lb)*(np.random.rand(self.pop,self.dim)-0.5)  
            self.V = np.clip(self.V,self.vmin,self.vmax)  
            self.X = self.X + self.V  
            self.X = np.clip(self.X,self.lb,self.ub)  
            Ys = np.array([self.func(x) for x in self.X])  
            improved = Ys > self.pbest_y  
            self.pbest_y = np.where(improved, Ys, self.pbest_y)  
            self.pbest_x = np.where(improved[:,None], self.X, self.pbest_x)  
            idx = np.argmax(self.pbest_y)  
            if self.pbest_y[idx] > self.gbest_y:  
                self.gbest_y = self.pbest_y[idx]  
                self.gbest_x = self.pbest_x[idx].copy()  
            self.gbest_y_hist.append(self.gbest_y)  
        return self.gbest_x, self.gbest_y, self.gbest_y_hist  
  
# -------------------------  
# 五种权重PSO  
# -------------------------  
class PSO_Fixed(SimplePSO):  
    def __init__(self, *a, w=0.7, **k):  
        super().__init__(*a, **k)  
        self.w = w  
    def update_w(self):  
        pass  
  
class PSO_Linear_Decreasing(SimplePSO):  
    def __init__(self, *a, w_start=0.9, w_end=0.4, **k):  
        super().__init__(*a, **k)  
        self.w_start=w_start; self.w_end=w_end; self.w=w_start  
    def update_w(self):  
        self.w = self.w_start - (self.w_start - self.w_end)*(self.iter/self.max_iter)  
  
class PSO_Adaptive(SimplePSO):  
    def __init__(self,*a, w_start=0.9,w_end=0.4,**k):  
        super().__init__(*a,**k)  
        self.w_start=w_start; self.w_end=w_end; self.w=w_start  
    def update_w(self):  
        if self.iter>1 and len(self.gbest_y_hist)>=2:  
            if self.gbest_y_hist[-1] < self.gbest_y_hist[-2]:  
                self.w=max(self.w*0.99,self.w_end)  
            else:  
                self.w=min(self.w*1.01,self.w_start)  
  
class PSO_Osculating(SimplePSO):  
    def __init__(self,*a, w_max=0.9,w_min=0.4,**k):  
        super().__init__(*a,**k)  
        self.w_max=w_max; self.w_min=w_min; self.w=w_max  
    def update_w(self):  
        self.w=self.w_max-(self.w_max-self.w_min)*(self.iter/self.max_iter)**2  
  
class PSO_Time_Varying(SimplePSO):  
    def __init__(self,*a, w_max=0.9,w_min=0.4,**k):  
        super().__init__(*a,**k)  
        self.w_max=w_max; self.w_min=w_min; self.w=w_max  
    def update_w(self):  
        self.w = (self.w_max-self.w_min)*np.exp(-self.iter/self.max_iter)+self.w_min  
  
# -------------------------  
# 主程序  
# -------------------------  
if __name__=="__main__":  
    num_drones = 3  
    FYs = [np.array([17800.0,0.0,1800.0]),  
           np.array([12000.0,1400.0,1400.0]),  
           np.array([6000.0,-3000.0,700.0])]  
  
    true_target_point = np.array([0.0,200.0,5.0])  
    lbs = [[70,-np.pi,0.5,1],[70,-np.pi,0.5,1],[75,-np.pi,25,1]]  
    ubs = [[140,np.pi,4,10],[140,np.pi,18,10],[140,np.pi,39,11.95]]  
  
    PSO_methods = [  
        ("固定权重", PSO_Fixed),  
        ("线性递减", PSO_Linear_Decreasing),  
        ("自适应", PSO_Adaptive),  
        ("振荡型", PSO_Osculating),  
        ("指数递减", PSO_Time_Varying)  
    ]  
  
    all_results = {}  
    start = time.time()  
  
    for method_name, PSO_class in PSO_methods:  
        print(f"\n===== 使用 {method_name} =====")  
        existing_clouds = []  
        pso_results = []  
  
        for i in range(num_drones):  
            def func_wrapper(x):  
                return simulate_incremental(x,FYs[i],existing_clouds)  
  
            pso = PSO_class(func_wrapper, dim=4, pop=40, max_iter=120, lb=lbs[i], ub=ubs[i])  
            bx, by, hist = pso.run()  
            pso_results.append((i+1,hist,bx,by))  
  
            # 更新已有云  
            t_hit_origin = np.linalg.norm(np.array([20000,0,2000]))/300.0  
            times = np.arange(0.0, t_hit_origin+0.01, 0.01)  
            drone_speed, theta, t_release, dt_release_to_explode = bx  
            FY = FYs[i]  
            vec_xy = np.array([drone_speed*np.sin(theta), drone_speed*np.cos(theta),0.0])  
            u_d_xy = vec_xy/np.linalg.norm(vec_xy) if np.linalg.norm(vec_xy)!=0 else np.array([0,1,0])  
            v_d = u_d_xy*drone_speed  
            r0 = FY + v_d*t_release  
            v0 = v_d.copy()  
            g = np.array([0,0,-9.8])  
            t_explosion = t_release + dt_release_to_explode  
            B_explosion = r0 + v0*(t_explosion - t_release) + 0.5*g*(t_explosion - t_release)**2  
            cpos = B_explosion[np.newaxis,:] + np.stack([np.zeros_like(times),np.zeros_like(times),-3*(times-t_explosion)],axis=1)  
            mpos = np.array([20000.0,0,2000])[np.newaxis,:] + (np.array([0.0,0.0,0.0])-np.array([20000.0,0,2000]))/np.linalg.norm(np.array([0.0,0.0,0.0])-np.array([20000.0,0,2000]))*300*times[:,None]  
            ab = true_target_point[np.newaxis,:]-mpos  
            ab_len2 = np.sum(ab**2,axis=1)  
            ab_len2_safe = np.where(ab_len2==0,1e-12,ab_len2)  
            tproj = np.sum((cpos-mpos)*ab,axis=1)/ab_len2_safe  
            within = (tproj>=0)&(tproj<=1)  
            closest = mpos + (tproj[:,None]*ab)  
            dists = np.linalg.norm(cpos-closest,axis=1)  
            blocked = (dists<=10)&within  
            existing_clouds.append(blocked)  
  
        total_block_time = sum(by for _,_,_,by in pso_results)  
        all_results[method_name] = (pso_results,total_block_time)  
  
    # -------------------------  
    # 输出每架无人机最大遮蔽时间及参数  
    # -------------------------  
    for method_name, (pso_results, total_block_time) in all_results.items():  
        print(f"\n===== {method_name} =====")  
        for i, hist, bx, by in pso_results:  
            drone_speed, theta, t_release, dt_release_to_explode = bx  
            print(f"第{i}架无人机:")  
            print(f"  最大增量遮蔽时间: {by:.3f} 秒")  
            print(f"  无人机速度: {drone_speed:.3f} m/s")  
            print(f"  方向角 theta: {theta:.3f} rad")  
            print(f"  投放时间 t_release: {t_release:.3f} s")  
            print(f"  投放到爆炸延时 dt_release_to_explode: {dt_release_to_explode:.3f} s")  
        print(f"{method_name} 总遮蔽时间: {total_block_time:.3f} 秒")  
  
    # 输出总体最佳方案  
    best_method_name, (best_results, best_total_time) = max(all_results.items(), key=lambda x: x[1][1])  
    print(f"\n===== 最佳权重算法 =====")  
    print(f"方法: {best_method_name}")  
    print(f"总遮蔽时间: {best_total_time:.3f} 秒")  
    for i, hist, bx, by in best_results:  
        drone_speed, theta, t_release, dt_release_to_explode = bx  
        print(f"第{i}架无人机参数:")  
        print(f"  最大增量遮蔽时间: {by:.3f} 秒")  
        print(f"  无人机速度: {drone_speed:.3f} m/s")  
        print(f"  方向角 theta: {theta:.3f} rad")  
        print(f"  投放时间 t_release: {t_release:.3f} s")  
        print(f"  投放到爆炸延时 dt_release_to_explode: {dt_release_to_explode:.3f} s")  
  
    # -------------------------  
    # 绘制收敛曲线  
    # -------------------------  
    plt.figure(figsize=(10,6))  
    for method_name, (pso_results,total_block_time) in all_results.items():  
        for i,hist,bx,by in pso_results:  
            plt.plot(hist,label=f"{method_name} 第{i}架无人机 增量遮蔽 {by:.2f}s")  
    plt.xlabel("迭代次数")  
    plt.ylabel("增量遮蔽时长 (秒)")  
    plt.title("不同权重算法 PSO 收敛曲线对比")  
    plt.grid(True)  
    plt.legend()  
    plt.show()  
  
    print("总耗时:", time.time()-start,"秒")




<!--stackedit_data:
eyJoaXN0b3J5IjpbLTczNDg4NDI0OV19
-->